

<!DOCTYPE html>
<html>

<head>
  <title>Arco Research &amp; Documentation</title>
  <meta charset='utf-8'>

  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/font-awesome.css">
  <link rel="stylesheet" href="/css/highlight-default.css">
  <link rel="stylesheet" href="/css/style.css">

  <link rel="icon" type="image/png"  href="/images/icon.png">
</head>

<body>
  <div id="content" class="container" style="padding-top: 15px">


<link rel="stylesheet" href="/recipes/css/style.css">

<div class="box">
  <a href="/">
    <img src="/images/arco-logo-128.png"
         style="padding: 0 25px" />
  </a>
  <h1 style="display: inline; font-weight: bold; font-size: 2.3em; padding-top: 10px">
    <a href="/recipes" style="color: inherit">Arco Recipes</a>
  </h1>
</div>

<hr style="border: 1px solid #333333">


<h1>Programming IceC in X86</h1>
<nav id="TableOfContents"></nav>

<div class="recipe-content">
  <h1 id="overview">Overview</h1>
<p>IceC is an object oriented communication middleware, written in C/C++, with a low use of the resources. This middleware is thought to small microcontrollers with limited resources, but is compatible with different architectures, in this example you are going to see how to program IceC in the architecture x86.</p>
<h1 id="ingredients">Ingredients</h1>
<p>In order to follow the next recipe you will need the following requirements:</p>
<ul>
<li>The <a href="https://arcogroup.bitbucket.io/icec/">icec</a> and <a href="https://arcogroup.bitbucket.io/recipes/st_getting_started/">smart-transducer</a> packages available at <a href="http://pike.esi.uclm.es/">Pike</a>&rsquo;s repository.</li>
<li>Basic knowledge of <strong>C</strong> and the tool <strong>make</strong>.</li>
<li>A Debian/Ubuntu <strong>Linux</strong> distribution.</li>
</ul>
<p>To install the required packages you have to execute the next command.</p>
<div class="app-skin shell">
  <div class="filename">console</div>
  
  <pre class=shell>$ sudo apt install icec smart-tranducer</pre>
</div>
<h1 id="an-icec-server-in-x86">An IceC server in x86</h1>
<p>The server will consist in an object that implement the <code>IBool</code> interface of the <code>st.ice</code> module, located in the path <code>/usr/share/slice/st/</code>.</p>
<p>The first step of the program must be implement the <code>set</code> function of the interface, in this example case, the implementation will be print a message with the new value in the <code>stdout</code>.</p>
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>void st_IBoolI_set(st_IBoolPtr self, Ice_Bool v, Ice_String sourceAddr)
{
    printf(&#34;The new value is %s\n&#34;, v ? &#34;true&#34; : &#34;false&#34;);
    fflush(NULL);
}</code></pre>
</div>
<p>The work flow in an IceC server will always be the same:</p>
<ol>
<li>
<p>Declare an ice communicator, an object adapter and the servants (an object that implements and ice interface) that the server is going to serve.
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>Ice_Communicator ic;
Ice_ObjectAdapter adapter;
st_IBool servant;</code></pre>
</div></p>
</li>
<li>
<p>Initialize the communicator and the endpoints of the communicator (<code>TCPEndpoint</code> or <code>UDPEndpoint</code>).
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>Ice_initialize(&amp;ic);
TCPEndpoint_init(&amp;ic);</code></pre>
</div></p>
</li>
<li>
<p>Create and activate the object adapter with their respective endpoints (ip address and port where the server is going to be listening).
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>Ice_Communicator_createObjectAdapterWithEndpoints(&amp;ic, &#34;Adapter&#34;, endp, &amp;adapter);
Ice_ObjectAdapter_activate(&amp;adapter);</code></pre>
</div></p>
</li>
<li>
<p>Initialize the servants with their respective types.
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>st_IBool_init(&amp;servant);</code></pre>
</div></p>
</li>
<li>
<p>Add the servants to the object adapter.
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>char *servant_identity = &#34;ServantIBool&#34;;
Ice_ObjectAdapter_add(&amp;adapter, (Ice_ObjectPtr)&amp;servant, servant_identity);</code></pre>
</div></p>
</li>
<li>
<p>Print the apropiate proxies with the structure <code>&quot;[identity] -e [ice_encoding_version] -[invocation_mode]:[endpoints]&quot;</code>.
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>printf(&#34;Proxy ready: &#39;%s -e 1.0 -o:%s&#39;\n&#34;, servant_identity, endp);</code></pre>
</div></p>
</li>
<li>
<p>Wait for calls to objects
<div class="app-skin">
  <div class="filename">
    
      snippet.c
    
  </div>
  
  <pre><code class='language-c'>Ice_Communicator_waitForShutdown(&amp;ic);</code></pre>
</div></p>
</li>
</ol>
<p>When you print the proxy is very important to consider some issues. Firstly IceC <strong>only support</strong> the version 1.0, if you want to communicate an Ice program with another written with IceC both have to work with the 1.0 version. Secondly, if you declare a tcp endpoint you have to print a proxy with a tcp invocation mode, the different invocations mode are <strong>-o(oneway)</strong> <strong>-t(twoway)</strong> for TCP and <strong>-d(datagram)</strong> for UDP.</p>
<p>After organize the code, your program should look like this one:</p>






<div class="app-skin">
  <div class="filename">
    <a download href="/recipes/code/programming_icec_in_x86/example_x86.c"
	     title="Click to download this code!">example_x86.c</a>
  </div>
  <pre><code class="language-">#include &lt;stdio.h&gt;
#include &lt;IceC/IceC.h&gt;
#include &lt;IceC/platforms/x86/TCPEndpoint.h&gt;

#include &#34;st.h&#34;


void st_IBoolI_set(st_IBoolPtr self, Ice_Bool v, Ice_String sourceAddr)
{
    printf(&#34;The new value is %s\n&#34;, v ? &#34;true&#34; : &#34;false&#34;);
    fflush(NULL);
}

int main()
{
    Ice_Communicator ic;
    Ice_ObjectAdapter adapter;
    st_IBool servant;
    char *endp = &#34;tcp -h 127.0.0.1 -p 10000&#34;;
    char *servant_identity = &#34;ServantIBool&#34;;

    Ice_initialize(&amp;ic);
    TCPEndpoint_init(&amp;ic);

    Ice_Communicator_createObjectAdapterWithEndpoints(&amp;ic, &#34;Adapter&#34;, endp, &amp;adapter);
    Ice_ObjectAdapter_activate(&amp;adapter);

    st_IBool_init(&amp;servant);
    Ice_ObjectAdapter_add(&amp;adapter, (Ice_ObjectPtr)&amp;servant, servant_identity);

    printf(&#34;Proxy ready: &#39;%s -e 1.0 -o:%s&#39;\n&#34;, servant_identity, endp);
    fflush(NULL);

    Ice_Communicator_waitForShutdown(&amp;ic);
    return 0;
}</code></pre>
</div>
<h1 id="compile-the-program-with-icec">Compile the program with IceC</h1>
<p>To simplify the task of compiling, it&rsquo;s going to be used a <code>Makefile</code> with the tool <code>make</code>.</p>
<p>The first task to do is define the variables that are going to be used in the compilation process, in this case we must define the compiler, some paths and the compilation flags that we will need.</p>
<div class="app-skin">
  <div class="filename">
    
      snippet.
    
  </div>
  
  <pre><code class='language-'>ICEC_SRC = /usr/src/IceC
DIRSLICE = /usr/share/slice/st/
TARGET = example_x86
SLICE = st

CC = gcc
CFLAGS &#43;= -I$(ICEC_SRC) #Flag to include the source code of IceC
CFLAGS &#43;= -Wall -Wextra -pedantic -Wno-variadic-macros -Wno-unused-parameter \
	   -Wno-unused-function</code></pre>
</div>
<p>Following we are going to used a powerfull tool of make, <code>vpath</code>. Thanks to it, we can indicate a set of directories where make will search for source files or prerequisites that are missing. In order to use IceC, it&rsquo;s necessary to obtain the object code of certain source files, with <code>vpath</code> the folder where that files are located can be indicated.</p>
<div class="app-skin">
  <div class="filename">
    
      snippet.
    
  </div>
  
  <pre><code class='language-'>vpath %.c $(ICEC_SRC)
vpath %.c $(ICEC_SRC)/platforms/x86</code></pre>
</div>
<p>Finally, we must include all the rules with their respective prerequisites to compile our program.</p>
<div class="app-skin">
  <div class="filename">
    
      snippet.
    
  </div>
  
  <pre><code class='language-'>all: $(SLICE).h $(TARGET)

$(SLICE).h: 
	slice2c $(DIRSLICE)$(SLICE).ice

$(TARGET): $(TARGET).c IceC.o IceUtil.o TCPEndpoint.o port.o
	$(CC) $(CFLAGS) $^ -o $@

run:
	./$(DIREXE)$(TARGET)

clean: 
	find -name &#34;*~&#34; -print -delete
	find -name &#34;*.o&#34; -print -delete
	$(RM) $(TARGET) $(SLICE).h</code></pre>
</div>
<p>As you can see, the two main files that are produce with this Makefile are the <strong>header file</strong> (in this case <code>st.h</code>) with the IceC interfaces and the executable. In order to obtain the executable, we have to link our source code with some <strong>object files of IceC</strong>. Because of the previous <code>vpath</code>, <code>make</code> will see the .o files like a prerequisites and will search the .c files in the paths that we indicated, producing the object files and compiling the program.</p>
<p>The entire Makefile will be the following.</p>






<div class="app-skin">
  <div class="filename">
    <a download href="/recipes/code/programming_icec_in_x86/Makefile"
	     title="Click to download this code!">Makefile</a>
  </div>
  <pre><code class="language-">ICEC_SRC = /usr/src/IceC
DIRSLICE = /usr/share/slice/st/
TARGET = example_x86
SLICE = st

CC = gcc
CFLAGS &#43;= -I$(ICEC_SRC) 
CFLAGS &#43;= -Wall -Wextra -pedantic -Wno-variadic-macros -Wno-unused-parameter \
	   -Wno-unused-function



vpath %.c $(ICEC_SRC)
vpath %.c $(ICEC_SRC)/platforms/x86

all: $(SLICE).h $(TARGET)

$(SLICE).h: 
	slice2c $(DIRSLICE)$(SLICE).ice

$(TARGET): $(TARGET).c IceC.o IceUtil.o TCPEndpoint.o port.o
	$(CC) $(CFLAGS) $^ -o $@

run:
	./$(DIREXE)$(TARGET)

clean: 
	find -name &#34;*~&#34; -print -delete
	find -name &#34;*.o&#34; -print -delete
	$(RM) $(TARGET) $(SLICE).h</code></pre>
</div>
<h1 id="executing-the-server">Executing the server</h1>
<p>Once developed the <code>Makefile</code>, compile and execute the program is as simple as execute the next commands in your shell.</p>
<div class="app-skin shell">
  <div class="filename">console</div>
  
  <pre class=shell>$ make
$ make run</pre>
</div>
<p>If you want to test your server you can use the <code>st-client</code> of the <code>smart-transducer</code> package.</p>
<div class="app-skin shell">
  <div class="filename">console</div>
  
  <pre class=shell>$ st-client -t bool -p &#34;ServantIBool -e 1.0 -o:tcp -h 127.0.0.1 -p 10000&#34; 1</pre>
</div>
<p>If all is correct the server must show the following message.</p>
<div class="app-skin shell">
  <div class="filename">console</div>
  
  <pre class=shell>Proxy ready: &#39;ServantIBool -e 1.0 -o:tcp -h 127.0.0.1 -p 10000&#39;
The new value is true</pre>
</div>

</div>



    </div> 

    <footer class="footer">
      <div class="container text-center">
        <a href="http://www.arcoresearch.com">ARCO Research Group</a> |
        <a href="/">Docs</a>&nbsp; - &nbsp;made with
        <a href="https://gohugo.io">Hugo</a> ·
        <a href="http://getbootstrap.com">Bootstrap</a>
      </div>
    </footer>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>


