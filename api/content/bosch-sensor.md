---
#
# WARNING: this is a generated file, modifications will be DISCARDED!!
#
# used command:
# ad-gen-py-api
#    --module-dir "/home/jfruiz/Escritorio/bosch-sensor/" 
#    --title "Library for the control of a MetaMotionR device" 
#    --image "None" 
#    --description "None" 
#    "metamotion" 
#

date: 2020-04-05T20:09:58+02:00
comment: "Documentation generated by Arco Docs Python API generator"
title: "MetaMotion Chip API reference"
description: "Python library to connect with the MetaMotion chip"
image: "metamotionr-api.png"
---

# Library for the control of a MetaMotionR device

## class index:
* <a href="#anchor-class-Accelerometer">Accelerometer</a>
* <a href="#anchor-class-Gyroscope">Gyroscope</a>
* <a href="#anchor-class-MetaMotion">MetaMotion</a>
* <a href="#anchor-class-WrongMetaDeviceModel">WrongMetaDeviceModel</a>

<hr>

# <span class="api-module">metamotion</span> API Documentation

## Class <span class="api-class">Accelerometer</span> {#anchor-class-Accelerometer}

Class for represent an Accelerometer sensor that is part of a MetaMotionR device
This class enable the user to request all the data that is provided by this accelerometer sensor


### <span class="api-func">`__init__`</span>

```py
def __init__(self, board, freq, motion_samples, motion_threshold, tap_threshold)
```

<br>Method for initialice the accelerometer sensor with the desired parameters. Also initializing the data,
this method subscribe for all the accelerometer signal and active the sensor

**Parameters:**

 * `board` *[mandatory]* this is the MetaMotionR Board where the sensor is located.
 * `freq` *[optional]* Frequency at which the acceleration is updated. By default, the frequency is
 25Hz what means that will be sent 25 acceleration signales per second.
 * `motion_samples` *[optional]* Number of samples that must overpass the `motion_threshold` in order
 to consider a motion.
 * `motion_threshold` *[optional]* Difference between the samples indicated in `motion_samples` to consider
 a motion.
 * `tap_threshold` *[optional]* Difference between samples acceleration to consider a tap.


### <span class="api-func">`active`</span>

```py
def active(self, acc_freq, motion_samples, motion_threshold, tap_threshold)
```

<br>Method to configure, active and enable all the accelerometer sensors of the device

**Parameters:**

 * `acc_freq` *[optional]* Frequency at which the acceleration is updated. By default, the frequency is
 25Hz what means that will be sent 25 acceleration signales per second.
 * `motion_samples` *[optional]* Number of samples that must overpass the `motion_threshold` in order
 to consider a motion.
 * `motion_threshold` *[optional]* Difference between the samples indicated in `motion_samples` to consider
 a motion.
 * `tap_threshold` *[optional]* Difference between samples acceleration to consider a tap.


### <span class="api-func">`get_callback`</span>

```py
def get_callback(self, attr, handler)
```

<br>Generic method to generate a callback that wil be executed when a signal 
from a sensor is received

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `handler` *[mandatory]* a user handler to process the data once received.


### <span class="api-func">`init_measures`</span>

```py
def init_measures(self)
```

<br>Subscribe the signal of the accelerometers measures in order to update the data


### <span class="api-func">`on_acceleration`</span>

```py
def on_acceleration(self, func=None)
```

<br>Add a handler to process the data received by the signal. If there is no handler, the data is
saver in the attribute

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`on_motion`</span>

```py
def on_motion(self, func=None)
```

<br>Subscribe to motion detector data and attach a handler that receives the motion as a parameter.

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`on_tap`</span>

```py
def on_tap(self, func=None)
```

<br>Subscribe tap data and attach a handler that receives tap as a parameter

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`read_acceleration`</span>

```py
def read_acceleration(self)
```

<br>Return the last acceleration detected by the sensor. The acceleration is formed by the following
fields:

* `x`: Acceleration in **X** axis in Gs units.
* `y`: Acceleration in **Y** axis in Gs units.
* `z`: Acceleration in **Z** axis in Gs units.


### <span class="api-func">`read_motion`</span>

```py
def read_motion(self)
```

<br>Return the last motion detected by the sensor. The motion is formed by the following fields:

* `sign`: Axis direction where the sensor is moving.
* `x_axis_active`: 1 if the motion was produced in the **X** axis.
* `y_axis_active`: 1 if the motion was produced in the **Y** axis.
* `z_axis_active`: 1 if the motion was produced in the **Z** axis.


### <span class="api-func">`read_step_counter`</span>

```py
def read_step_counter(self)
```

<br>Return the number of steps that the user has made


### <span class="api-func">`read_tap`</span>

```py
def read_tap(self)
```

<br>Return the last tap detected by the sensor. The tap is formed by the following fields:

* `sign`: Axis direction where the tap is detected.
* `type`: **2** if only 1 tap is detected, **1** if 2 taps.


### <span class="api-func">`setup_logger`</span>

```py
def setup_logger(self)
```

<br>Create and initialize an accelerometer logger


### <span class="api-func">`subscribe_logged_data`</span>

```py
def subscribe_logged_data(self)
```

<br>Subscribe to the accelerometer logger in order to receive the acceleration data 
when the download action is performed


### <span class="api-func">`subscribe_signal`</span>

```py
def subscribe_signal(self, attr, signal_subscriber, func=None)
```

<br>Method to subscribe a client to a signal, indicating the attribute where the 
data received must be saved, the method to subscribe to the signal and the user function
that will process the data. If no function is indicated, the data will be saved only

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `signal_subscriber` *[mandatory]* is the metawear function that enable the
 user to receive data from a signal.
 * `func` *[optional]* a user handler to process the data once received.


### <span class="api-func">`wait_until_download_completed`</span>

```py
def wait_until_download_completed(self)
```

<br>Wait until the acceleration data is fully downloaded

## Class <span class="api-class">Gyroscope</span> {#anchor-class-Gyroscope}

Class for represent a Gyroscope of a MetaMotionR device, this class enables
the user to gather the rotation data from the gyroscope sensor


### <span class="api-func">`__init__`</span>

```py
def __init__(self, board, freq)
```

<br>Method to initalize the gyroscope client. The initialization include the activation
of the gyroscope and subscription in order to update the attributes


### <span class="api-func">`active`</span>

```py
def active(self, freq)
```

<br>Active and configure the gyroscope sensor with default configuration


### <span class="api-func">`get_callback`</span>

```py
def get_callback(self, attr, handler)
```

<br>Generic method to generate a callback that wil be executed when a signal 
from a sensor is received

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `handler` *[mandatory]* a user handler to process the data once received.


### <span class="api-func">`init_measures`</span>

```py
def init_measures(self)
```

<br>Subcribe to rotation data in order to update the attribute saving the data


### <span class="api-func">`on_rotation`</span>

```py
def on_rotation(self, func=None)
```

<br>Add a handler to process the data received by the signal. If there is no handler, the data is
saved in the attribute self.gyro

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`read_rotation`</span>

```py
def read_rotation(self)
```

<br>Return the last rotation detected by the sensor. The rotation is formed by the following 
attributes:

* `x`: Rotation in the *X* axis in degrees per second.
* `y`: Rotation in the *Y* axis in degrees per second.
* `z`: Rotation in the *Z* axis in degrees per second.


### <span class="api-func">`setup_logger`</span>

```py
def setup_logger(self)
```

<br>Create and initialize a rotation logger


### <span class="api-func">`subscribe_logged_data`</span>

```py
def subscribe_logged_data(self)
```

<br>Subscribe to the rotation logger in order to receive the rotation data 
when the download action is performed


### <span class="api-func">`subscribe_signal`</span>

```py
def subscribe_signal(self, attr, signal_subscriber, func=None)
```

<br>Method to subscribe a client to a signal, indicating the attribute where the 
data received must be saved, the method to subscribe to the signal and the user function
that will process the data. If no function is indicated, the data will be saved only

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `signal_subscriber` *[mandatory]* is the metawear function that enable the
 user to receive data from a signal.
 * `func` *[optional]* a user handler to process the data once received.


### <span class="api-func">`translate_frequency`</span>

```py
def translate_frequency(self, desired_freq)
```

<br>Translate a numeric frequency in the corresponding macro


### <span class="api-func">`wait_until_download_completed`</span>

```py
def wait_until_download_completed(self)
```

<br>Wait until the rotation data is fully downloaded

## Class <span class="api-class">MetaMotion</span> {#anchor-class-MetaMotion}

This class is used for request and add handlers for MetaMotionR sensor
This is an abstraction of the Mbientlab Metawear API. This class has two
main attributes that represents the sensors that formed the device:

* accelerometer: Instance of the `Accelerometer` class
* gyroscope: Instance of the `Gyroscope` class


### <span class="api-func">`__init__`</span>

```py
def __init__(self, mac_address)
```

<br>MetaMotion constructor. This method is the start point of the library 
and must be invoked in order to use the library characteristics

**Parameters:**

 * `mac_address`, *[mandatory]* the MAC addres of the MetaMotion sensor
    that will be used in order to connect it by blutooth.


### <span class="api-func">`check_model`</span>

```py
def check_model(self, model)
```

<br>Check if the model of the connected device is the MetaMotionR

**Parameters:**

* `model`, *[mandatory]* the model of the device connected.


### <span class="api-func">`connect`</span>

```py
def connect(self)
```

<br>Method to make the bluetooth connection with the MetaMotion sensor. It includes some
necessary initialization for the library, like create an instance for the sensors and 
subscribe to some events. Also, check that the model of the sensor that we are connecting 
is the properly (MetaMotionR)


### <span class="api-func">`disconnect`</span>

```py
def disconnect(self)
```

<br>Disables all the sensors of the MetaMotionR device, and clean and disconnect
it.


### <span class="api-func">`download_logs`</span>

```py
def download_logs(self)
```

<br>Download the data saved in the logs previosuly created in a MetaMotion device


### <span class="api-func">`get_device_info`</span>

```py
def get_device_info(self)
```

<br>Returns a string with the basic information of the device


### <span class="api-func">`read_battery`</span>

```py
def read_battery(self)
```

<br>**Return information about the battery of the device. It has two fields:**

* `voltage`: Voltage that feed the device.
* `charge`: Percentage of battery that the sensor has. 


### <span class="api-func">`setup_accelerometer`</span>

```py
def setup_accelerometer(self, freq=25, motion_samples=4, motion_threshold=0.7, tap_threshold=1)
```

<br>Initialize the accelerometer sensors that is part of the MetaMotionR device. Is mandatory to
invoke this method before use any funcionalities of the accelerometer.

**Parameters:**

 * `freq` *[optional]* Frequency at which the acceleration is updatea. By default, the frequency is
 25Hz what means that will be sent 25 acceleration signales per second. 
 * `motion_samples` *[optional]* Number of samples that must overpass the `motion_threshold` in order
 to consider a motion.
 * `motion_threshold` *[optional]* Difference between the samples indicated in `motion_samples` to consider
 a motion.
 * `tap_threshold` *[optional]* Difference between samples acceleration to consider a tap.


### <span class="api-func">`setup_gyroscope`</span>

```py
def setup_gyroscope(self, freq=25)
```

<br>Initialize the gyroscope sensor that is part of the MetaMotionR device. Is mandatory to
invoke this method before use any funcionalities of the gyroscope.

**Parameters:**

 * `freq` *[optional]* Frequency at which the rotation is updated. By default the frequency is 25Hz. The library
 will try to assign the frequency closest to that indicated by the user and allowed by the sensor.


### <span class="api-func">`start_logging`</span>

```py
def start_logging(self)
```

<br>Start to logging the data


### <span class="api-func">`stop_logging`</span>

```py
def stop_logging(self)
```

<br>Stop data logging.


### <span class="api-func">`subscribe_battery`</span>

```py
def subscribe_battery(self)
```

<br>Subscribe for battery signal in order tu update the battery level attribute

## Class <span class="api-class">WrongMetaDeviceModel</span> {#anchor-class-WrongMetaDeviceModel}

Common base class for all non-exit exceptions.

