---
#
# WARNING: this is a generated file, modifications will be DISCARDED!!
#
# used command:
# ad-gen-py-api
#    --module-dir "/home/jfruiz/Escritorio/bosch-sensor/" 
#    --title "Library for the control of a MetaMotionR device" 
#    --image "None" 
#    --description "None" 
#    "metamotion" 
#

date: 2020-04-01T12:51:14+02:00
comment: "Documentation generated by Arco Docs Python API generator"
title: "Library for the control of a MetaMotionR device"
description: "This is an API that provide a simple way to query the data that is produced by a MetaMotionR sensor and attach handlers to the different events produced by the device"
image: "metamotionr-api.png"
---

# Library for the control of a MetaMotionR device

## class index:
* <a href="#anchor-class-Accelerometer">Accelerometer</a>
* <a href="#anchor-class-Gyroscope">Gyroscope</a>
* <a href="#anchor-class-MetaMotion">MetaMotion</a>
* <a href="#anchor-class-WrongMetaDeviceModel">WrongMetaDeviceModel</a>

<hr>

# <span class="api-module">metamotion</span> API Documentation

## Class <span class="api-class">Accelerometer</span> {#anchor-class-Accelerometer}

Class for represent an Accelerometer sensor that is part of a MetaMotionR device
This class enable the user to request all the data that is provided by this accelerometer sensor


### <span class="api-func">`__init__`</span>

```py
def __init__(self, board, freq=25, motion_samples=4, motion_threshold=0.7, tap_threshold=1)
```

<br>Method for initialice the accelerometer sensor with the desired parameters. Also initializing the data,
this method subscribe for all the accelerometer signal and active the sensor

**Parameters:**

 * `board` *[mandatory]* this is the MetaMotionR Board where the sensor is located.
 * `freq` *[optional]* Frequency of the acceleration update. By default, the frequency is 
 25Hz what means that will be sent 25 acceleration signales per second,
 * `motion_samples` *[optional]* Number of samples that must overpass the `motion_threshold` in order
 to consider a motion.
 * `motion_threshold` *[optional]* Difference between the samples indicated in `motion_samples` to consider
 a motion.
 * `tap_threshold` *[optional]* Difference between samples acceleration to consider a tap.  


### <span class="api-func">`active`</span>

```py
def active(self, acc_freq, motion_samples, motion_threshold, tap_threshold)
```

<br>Method to configure, active and enable all the accelerometer sensors of the device

**Parameters:**

 * `acc_freq` *[optional]* Frequency of the acceleration update. By default, the frequency is 
 25Hz what means that will be sent 25 acceleration signales per second.
 * `motion_samples` *[optional]* Number of samples that must overpass the `motion_threshold` in order
 to consider a motion.
 * `motion_threshold` *[optional]* Difference between the samples indicated in `motion_samples` to consider
 a motion.
 * `tap_threshold` *[optional]* Difference between samples acceleration to consider a tap.


### <span class="api-func">`get_callback`</span>

```py
def get_callback(self, attr, handler)
```

<br>Generic method to generate a callback that wil be executed when a signal 
from a sensor is received

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `handler` *[mandatory]* a user handler to process the data once received.


### <span class="api-func">`init_measures`</span>

```py
def init_measures(self)
```

<br>Subscribe the signal of the accelerometers measures in order to update the data


### <span class="api-func">`on_acceleration`</span>

```py
def on_acceleration(self, func=None)
```

<br>Add a handler to process the data received by the signal. If there is no handler, the data is
saver in the attribute

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`on_motion`</span>

```py
def on_motion(self, func=None)
```

<br>Subscribe to motion detector data and attach a handler that receives the motion as a parameter.

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`on_tap`</span>

```py
def on_tap(self, func=None)
```

<br>Subscribe tap data and attach a handler that receives tap as a parameter

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`read_acceleration`</span>

```py
def read_acceleration(self)
```

<br>Return the last acceleration detected by the sensor. The acceleration is formed by the following
fields:

* `x`: Acceleration in **X** axis in Gs units.
* `y`: Acceleration in **Y** axis in Gs units.
* `z`: Acceleration in **Z** axis in Gs units.


### <span class="api-func">`read_motion`</span>

```py
def read_motion(self)
```

<br>Return the last motion detected by the sensor. The motion is formed by the following fields:

* `sign`: Axis direction where the sensor is moving.
* `x_axis_active`: 1 if the motion was produced in the **X** axis.
* `y_axis_active`: 1 if the motion was produced in the **Y** axis.
* `z_axis_active`: 1 if the motion was produced in the **Z** axis.


### <span class="api-func">`read_step_counter`</span>

```py
def read_step_counter(self)
```

<br>Return the number of steps that the user has made


### <span class="api-func">`read_tap`</span>

```py
def read_tap(self)
```

<br>Return the last tap detected by the sensor. The tap is formed by the following fields:

* `sign`: Axis direction where the tap is detected.
* `type`: **2** if only 1 tap is detected, **1** if 2 taps.


### <span class="api-func">`subscribe_signal`</span>

```py
def subscribe_signal(self, attr, signal_subscriber, func=None)
```

<br>Method to subscribe a client to a signal, indicating the attribute where the 
data received must be saved, the method to subscribe to the signal and the user function
that will process the data. If no function is indicated, the data will be saved only

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `signal_subscriber` *[mandatory]* is the metawear function that enable the
 user to receive data from a signal.
 * `func` *[optional]* a user handler to process the data once received.

## Class <span class="api-class">Gyroscope</span> {#anchor-class-Gyroscope}

Class for represent a Gyroscope of a MetaMotionR device, this class enables
the user to gather the rotation data from the gyroscope sensor


### <span class="api-func">`__init__`</span>

```py
def __init__(self, board)
```

<br>Method to initalize the gyroscope client. The initialization include the activation
of the gyroscope and subscription in order to update the attributes


### <span class="api-func">`active`</span>

```py
def active(self)
```

<br>Active and configure the gyroscope sensor with default configuration


### <span class="api-func">`get_callback`</span>

```py
def get_callback(self, attr, handler)
```

<br>Generic method to generate a callback that wil be executed when a signal 
from a sensor is received

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `handler` *[mandatory]* a user handler to process the data once received.


### <span class="api-func">`init_measures`</span>

```py
def init_measures(self)
```

<br>Subcribe to rotation data in order to update the attribute saving the data


### <span class="api-func">`on_rotation`</span>

```py
def on_rotation(self, func=None)
```

<br>Add a handler to process the data received by the signal. If there is no handler, the data is
saved in the attribute self.gyro

**Parameter:**

 * `func` *[optional]* a handler to process the data.


### <span class="api-func">`read_rotation`</span>

```py
def read_rotation(self)
```

<br>Return the last rotation detected by the sensor. The rotation is formed by the following 
attributes:

* `x`: Rotation in the *X* axis in degrees per second.
* `y`: Rotation in the *Y* axis in degrees per second.
* `z`: Rotation in the *Z* axis in degrees per second.


### <span class="api-func">`subscribe_signal`</span>

```py
def subscribe_signal(self, attr, signal_subscriber, func=None)
```

<br>Method to subscribe a client to a signal, indicating the attribute where the 
data received must be saved, the method to subscribe to the signal and the user function
that will process the data. If no function is indicated, the data will be saved only

**Parameter:**

 * `attr` *[mandatory]* this is the class atribute where the data recived by
 the signal is going to be saved.
 * `signal_subscriber` *[mandatory]* is the metawear function that enable the
 user to receive data from a signal.
 * `func` *[optional]* a user handler to process the data once received.

## Class <span class="api-class">MetaMotion</span> {#anchor-class-MetaMotion}

This class is used for request and add handlers for MetaMotionR sensor
This is an abstraction of the Mbientlab Metawear API. This class has two
main attributes that represents the sensors that formed the device:

* accelerometer: Instance of the `Accelerometer` class
* gyroscope: Instance of the `Gyroscope` class


### <span class="api-func">`__init__`</span>

```py
def __init__(self, mac_address)
```

<br>MetaMotion constructor. This method is the start point of the library 
and must be invoked in order to use the library characteristics

**Parameters:**

 * `mac_address`, *[mandatory]* the MAC addres of the MetaMotion sensor
    that will be used in order to connect it by blutooth.


### <span class="api-func">`check_model`</span>

```py
def check_model(self, model)
```

<br>Check if the model of the connected device is the MetaMotionR

**Parameters:**

* `model`, *[mandatory]* the model of the device connected.


### <span class="api-func">`connect`</span>

```py
def connect(self)
```

<br>Method to make the bluetooth connection with the MetaMotion sensor. It includes some
necessary initialization for the library, like create an instance for the sensors and 
subscribe to some events. Also, check that the model of the sensor that we are connecting 
is the properly (MetaMotionR)


### <span class="api-func">`disconnect`</span>

```py
def disconnect(self)
```

<br>Disables all the sensors of the MetaMotionR device, and clean and disconnect
it.


### <span class="api-func">`read_battery`</span>

```py
def read_battery(self)
```

<br>**Return information about the battery of the device. It has two fields:**

* `voltage`: Voltage that feed the device.
* `charge`: Percentage of battery that the sensor has. 


### <span class="api-func">`subscribe_battery`</span>

```py
def subscribe_battery(self)
```

<br>Subscribe for battery signal in order tu update the battery level attribute

## Class <span class="api-class">WrongMetaDeviceModel</span> {#anchor-class-WrongMetaDeviceModel}

Common base class for all non-exit exceptions.

