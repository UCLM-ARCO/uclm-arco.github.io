---
title: "Mijia Smart Home API reference"
comment: "Documentation generated by Arco Docs Python API generator"
date: 2019-02-25T14:57:27+01:00
---

# Mijia Smart Home API reference

## class index:
* <a href="#anchor-class-LumiGateway">LumiGateway</a>
* <a href="#anchor-class-CubeAqgl01">CubeAqgl01</a>
* <a href="#anchor-class-Magnet">Magnet</a>
* <a href="#anchor-class-Motion">Motion</a>
* <a href="#anchor-class-Plug">Plug</a>
* <a href="#anchor-class-Switch">Switch</a>
* <a href="#anchor-class-WeatherV1">WeatherV1</a>

<hr>

# <span class="api-module">mijia</span> API Documentation

## Class <span class="api-class">LumiGateway</span> {#anchor-class-LumiGateway}

This class is used to access a ***Lumi Gateway device*** (provided by Xiaomi / Aqara).
It will automatically try to discover devices on your network, using the *Lumi LAN
protocol*. It installs a thread to listen for incomming events, and also allows you
to change the device light color.


### <span class="api-prop">`illumination`</span>
[read only property] Stores the Gateway's provided value for its **light
sensor**. It's updated when a *change* event arrives, and on start-up.


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-func">`__init__`</span>

```py
def __init__(self, passwd=None, mcast_member=None)
```

<br>LumiGateway constructor. This is the **starting point** of the library. You will need
to create an instance of this class, and use it access other devices.

**Parameters:**

* `password`, *[optional]* the Wireless communication protocol **password**, needed to
  change the state of any device (which performs a `write` on the device).
* `mcast_member`, *[optional]* the IP address of the interface that will be used as
  the **multicast member**. This address is used to receive events from the Lumi Gateway.
  If not provided, it will try to **automatically** determine it.


### <span class="api-func">`get_devices`</span>

```py
def get_devices(self, filter=None)
```

<br>Returns a **dictionary** (pairs of `sid` and `Device` objects) with the
currently linked devices.

**Parameters:**

* `filter`: used to retrieve **only** devices of the given type. You
  could use the class of a `Device`, its `type` property or even the
  type value. For instance, to get only the `Switch` objects, you may
  use any of the following options:

`gw.get_devices(filter=Switch)`<br>
`gw.get_devices(filter=Switch.type)`<br>
`gw.get_devices(filter="switch")`


### <span class="api-func">`light_off`</span>

```py
def light_off(self)
```

<br>Switch **off** Gateway's light. The same result could be achieved
providing 0 as intensity on `set_light_color()`.


### <span class="api-func">`on_change`</span>

```py
def on_change(self, cb)
```

<br>Stablish a callback to be called when the Gateway's light sensor
changes. The callback signature should be as follows:

`def callback([self,] event, device)`

Where `event` is the **name** of this event (*change*), and `device` is
the Gateway device. To retrieve the **current value** of the light sensor,
use the property `illumination`.


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`set_light_color`</span>

```py
def set_light_color(self, r=0, g=0, b=0, i=0)
```

<br>Changes the Gateway's light to the given **color** (by RGB components)
and **intensity**. Note that the provided values are **relative** to
each other, so a value of (1, 0, 0) will produce the same result as
(255, 0, 0).

**Parameters:**

* `r`: int in range [0, 255]; **red** component of the light's color.
* `g`: int in range [0, 255]; **green** component of the light's color.
* `b`: int in range [0, 255]; **blue** component of the light's color.
* `i`: int in range [0, 100]; light **intensity**.


### <span class="api-func">`start`</span>

```py
def start(self)
```

<br>Start the **discovery process**. It will search for an active gateway, and then list its
linked devices. It also starts the *listening thread* to receive messages from
the Gateway. You usually will **need** to call this method.


### <span class="api-func">`wait_until_break`</span>

```py
def wait_until_break(self)
```

<br>**Blocks** the calling thread execution until it receives a `KeyboardInterrupt` (Ctrl+C)
Use it (or use instead an **event loop**) to keep the application **running** while
you wait for incoming events.

<hr>

# <span class="api-module">mijia.devices</span> API Documentation

## Class <span class="api-class">CubeAqgl01</span> {#anchor-class-CubeAqgl01}

Mi Cube Controller, which is a device that detects **different movements**
or actions performed on itself: tap, double tap, flips of 90 and 180
degrees, rotation, move, shake, swing and free fall. It also works as a
**motion sensor**: when you touches it after a while, it will send an
`alert` event.

Except for the `rotate` event, all the attached callbacks should be in the
form:

`def callback([self,], event, device)`

Where `event` is the name of this event, and `device` is the device object
that produced the event.


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-func">`on_alert`</span>

```py
def on_alert(self, cb)
```

<br>Attach a callback handler for `alert` events. These events are sent when
the cube is **moved after some time** of inactivity (no movement).


### <span class="api-func">`on_flip180`</span>

```py
def on_flip180(self, cb)
```

<br>Attach a callback handler for `flip180` events. These events are produced
when the cube is **flipped 180 degrees** (i.e rotated on X and Y axis).


### <span class="api-func">`on_flip90`</span>

```py
def on_flip90(self, cb)
```

<br>Attach a callback handler for `flip90` events. These events are produced
when the cube is **flipped 90 degrees** (i.e rotated on X and Y axis).


### <span class="api-func">`on_free_fall`</span>

```py
def on_free_fall(self, cb)
```

<br>Attach a callback handler for `free_fall` events, which are sent when
you **drop the cube** (or it experiments some acceleration on the vertical axis).


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`on_move`</span>

```py
def on_move(self, cb)
```

<br>Attach a callback handler for `move` events, generated when you **displace
the cube** some small distance on the horizontal plane.


### <span class="api-func">`on_rotate`</span>

```py
def on_rotate(self, cb)
```

<br>Attach a callback handler for `rotate` events, which are sent when you
**rotate** the cube along the vertical axis (Z axis).

The attached callbacks should be in the form:

`def callback([self,], event, device, degrees, time)`

Where `event` is the name of this event, `device` is the device object
that produced the event, `degrees` is the angle of the rotation, and
`time` is the time that took the sensor to measure the angle.


### <span class="api-func">`on_shake_air`</span>

```py
def on_shake_air(self, cb)
```

<br>Attach a callback handler for `shake_air` events, which are sent when
you take the cube and **shake it** on the air.


### <span class="api-func">`on_swing`</span>

```py
def on_swing(self, cb)
```

<br>Attach a callback handler for `swing` events. These events are signaled
when the cube makes a **fast swing** movement (one single shot is enough).
Note that it is also a trigger for the `iam` event (used to link the
cube to a Gateway).


### <span class="api-func">`on_tap_twice`</span>

```py
def on_tap_twice(self, cb)
```

<br>Attach a callback handler for `tap_twice` events. These events are sent when
the cube is **knocked twice** on an horizontal hard surface.

## Class <span class="api-class">Magnet</span> {#anchor-class-Magnet}

Aqara **reed sensor** (magnet) for detection of opening and close of doors
and windows. It emits an `open` event when the two components of the sensor
are separated, and a `close` event when they are joined together. Also,
`no_close` events are sent when the **elapsed** time from the last `open`
event **reaches** some pre-established thresholds (in the sensor firmware or
in the Gateway).


### <span class="api-prop">`elapsed_no_close`</span>
Gives the amount of elapsed **time** (in seconds) from the last `open`
event. It is **provided** with the `no_close` event from the sensor (not
computed locally).


### <span class="api-prop">`open`</span>
`True` if the sensor detects that the door/window is open (or the two
components of the sensore are not together). `False` otherwise.


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-func">`on_close`</span>

```py
def on_close(self, cb)
```

<br>Attach a callback handler for `close` events, which are sent when the
sensor detects the **closing** of the door/window. The attached callback
should be in the form:

`def callback([self,], event, device)`

Where `event` is the name of this event, and `device` is the device
object that produced the event.


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`on_no_close`</span>

```py
def on_no_close(self, cb)
```

<br>Attach a callback handler for `no_close` events, which are sent when the
**elapsed time** from the last `open` event reaches certain
thresholds (120 seconds, 300, 600, and so on). The elapsed time is
provided in the event, so the attached callback should be in the form:

`def callback([self,], event, device, elapsed)`

Where `event` is the name of this event, and `device` is the device
object that produced the event.


### <span class="api-func">`on_open`</span>

```py
def on_open(self, cb)
```

<br>Attach callback handler for `open` events, which are sent when the
sensor detects the **opening** of the door/window. The attached callback
should be in the form:

`def callback([self,], event, device)`

Where `event` is the name of this event, and `device` is the device
object that produced the event.

## Class <span class="api-class">Motion</span> {#anchor-class-Motion}

This is the Aqara **PIR** (or motion) sensor. It emits an event when a
**moving** object is detected, and some other events when the **elapsed**
time from the last motion detected **reaches** some pre-established
thresholds (in the sensor firmware or in the Gateway).


### <span class="api-prop">`elapsed_no_motion`</span>
Gives the amount of elapsed **time** (in seconds) between the last `motion`
event and the last `no_motion` event. It is **provided** with the `no_motion`
event from the sensor (not computed locally).


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`on_motion`</span>

```py
def on_motion(self, cb)
```

<br>Attach a callback handler for `motion` events, which are sent when a
moving object passes through the field of view of the sensor. The
attached callback should be in the form:

`def callback([self,], event, device)`

Where `event` is the name of this event, and `device` is the device
object that produced the event.


### <span class="api-func">`on_no_motion`</span>

```py
def on_no_motion(self, cb)
```

<br>Attach a callback handler for `no_motion` events, which are sent when the
**elapsed time** from the last detected motion reaches certain
thresholds (120 seconds, 300, 600, and so on). The elapsed time is
provided in the event, so the attached callback should be in the form:

`def callback([self,], event, device, elapsed)`

Where `event` is the name of this event, and `device` is the device
object that produced the event.

## Class <span class="api-class">Plug</span> {#anchor-class-Plug}

This is the Aqara plug controller. Emits **2** different events, to
**notify** if someone enabled or disabled the plug. You can also **change
the state** of the plug: enable or disable it. The properties `enabled` and
`inuse` will give you **information** about the plug usage.

All event callbacks **should met** the following signature:

`def callback([self,], event, device)`

Where `event` is the name of the event, and `device` is the device object
that produced this event.


### <span class="api-prop">`enabled`</span>
`True` if the plug is enabled (provides energy to the connected
appliance), `False` otherwise.


### <span class="api-prop">`inuse`</span>
`True` if there are a **connected** appliance, and it is currently **consuming**
energy. `False` otherwise.


### <span class="api-prop">`load_power`</span>
Connected appliance (load) power usage, in watts (W).


### <span class="api-prop">`power_consumed`</span>
The cumulative load **power consumption** since the product was used, in
Wh.


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`on_switch_off`</span>

```py
def on_switch_off(self, cb)
```

<br>Attach callback handler for `switch_off` events, which are sent when
someone presses the **built-in** button of the plug (or otherwise
changes the **enabled** state), and the state goes from `on` to `off`.


### <span class="api-func">`on_switch_on`</span>

```py
def on_switch_on(self, cb)
```

<br>Attach callback handler for `switch_on` events, which are sent when
someone presses the **built-in** button of the plug (or otherwise
changes the **enabled** state), and the state goes from `off` to `on`.


### <span class="api-func">`switch_off`</span>

```py
def switch_off(self)
```

<br>Call this method to **disable** the plug (does **not** provide energy to
connected appliance). Remember that you must provide a **password** on
the Gateway construction for this method to work.


### <span class="api-func">`switch_on`</span>

```py
def switch_on(self)
```

<br>Call this method to **enable** the plug (provide energy to connected
appliance). Remember that you must provide a **password** on the Gateway
construction for this method to work.

## Class <span class="api-class">Switch</span> {#anchor-class-Switch}

This is the Aqara push button that emits **4** different events. All event
callbacks **should met** the following signature:

`def callback([self,], event, device)`

Where `event` is the name of the event, and `device` is the device object
that produced this event.


### <span class="api-prop">`pressed`</span>
Property to retrieve the **current state** of the push button: `true` is
pressed, `false` is not pressed.


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-func">`on_click`</span>

```py
def on_click(self, cb)
```

<br>Attach callback handler for `click` events, which is a **single press** on
the button.


### <span class="api-func">`on_double_click`</span>

```py
def on_double_click(self, cb)
```

<br>Attach callback handler for `double_click` events, which is a **double press** on
the button.


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`on_long_click_press`</span>

```py
def on_long_click_press(self, cb)
```

<br>Attach callback handler for `long_click_press` events. These events are
produced when the button is **pressed and maintained** for more that 1
second. It is paired with the `long_click_release` event.


### <span class="api-func">`on_long_click_release`</span>

```py
def on_long_click_release(self, cb)
```

<br>Attach callback handler for `long_click_release` events. These events
are produced when the button is pressed, maintained for more that 1
second and then **released**. It is paired with the `long_click_press`
event.

## Class <span class="api-class">WeatherV1</span> {#anchor-class-WeatherV1}

Aqara weather sensor (version 1.0). It provides readings for
**temperature**, **humidity** and air **pressure**. The latest provided
values for these magnitudes **could be read** any time from the
corresponding properties.

All event callbacks **should met** the following signature:

`def callback([self,], event, device, value)`

Where `event` is the name of the event, `device` is the device object that
produced this event, and `value` is the provided value (as **integer**) for that
magnitude.


### <span class="api-prop">`humidity`</span>
Last value provided on a **humidity event** (or retrieved on startup).


### <span class="api-prop">`pressure`</span>
Last value provided on a **pressure event** (or retrieved on startup).


### <span class="api-prop">`status`</span>
A property that provides the status of this device, which could be:

* `unknown`: there is **not enough** information to set a valid status. It receives
  this state when the object is first created.
* `online`: some message arrived **recently** from the device, so it is up
  and running correctly.
* `offline`: the device has **not sent** a heartbeat during its heartbeat period
 (which is variable, but usually 10 minutes on battery devices).


### <span class="api-prop">`temperature`</span>
Last value provided on a **temperature event** (or retrieved on startup).


### <span class="api-func">`on_heartbeat`</span>

```py
def on_heartbeat(self, cb)
```

<br>Installs an **event handler** that will be called when this device sends a `heartbeat`
message.

**Parameters:**

* `cb`: callback function to be called. It must **accept two** parameters: the event
  **name** (a string), and the **device** that produces the event (a `Device` or
  derived object).


### <span class="api-func">`on_humidity`</span>

```py
def on_humidity(self, cb)
```

<br>Attach callback handler for `humidity` events. Only sent when value
**changes** from previous one.


### <span class="api-func">`on_pressure`</span>

```py
def on_pressure(self, cb)
```

<br>Attach callback handler for `pressure` events. Only sent when value
**changes** from previous one.


### <span class="api-func">`on_temperature`</span>

```py
def on_temperature(self, cb)
```

<br>Attach callback handler for `temperature` events. Only sent when value
**changes** from previous one.

